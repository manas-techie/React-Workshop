========================================================
   09 - THEME SWITCHER (Context API + Tailwind Dark Mode)
========================================================

>> What This Project Does:
   - A dark/light theme toggle switch
   - Toggle button switches between dark and light mode
   - Card component changes its colors based on the current theme
   - Uses Context API to share theme state across components

========================================================
>> HOW THIS PROJECT IS DIFFERENT FROM 08miniContext
========================================================

   In 08miniContext:
     - Created context in one file (UserContext.js)
     - Created provider in a SEPARATE file (UserContextProvider.jsx)
     - Used useContext() directly in components

   In 09themeSwitcher (CLEANER approach):
     - EVERYTHING in ONE file (theme.js):
       • Created context
       • Exported the Provider
       • Created a CUSTOM HOOK (useTheme) for easy access
     - No separate provider component file needed!

========================================================
>> FILES & THEIR ROLES
========================================================

   contexts/theme.js    → Context + Provider export + custom hook (all in one!)
   App.jsx              → Holds theme state + wraps with ThemeProvider
   ThemeBtn.jsx         → Toggle switch (reads & changes theme via context)
   Card.jsx             → Product card (styled with Tailwind dark: classes)
   index.css            → Tailwind config with custom dark variant

========================================================
>> THE CONTEXT FILE — theme.js (All-in-One)
========================================================

   File: src/contexts/theme.js

   // Step 1: CREATE context with DEFAULT values
   export const ThemeContext = createContext({
       themeMode: "light",
       darkTheme: () => { },      ← empty functions as defaults
       lightTheme: () => { },
   })

   // Step 2: EXPORT the Provider directly
   export const ThemeProvider = ThemeContext.Provider;

   // Step 3: CUSTOM HOOK for easy access
   export default function useTheme() {
       return useContext(ThemeContext);
   }

   KEY DIFFERENCES from 08miniContext:
   ┌─────────────────────────────────────────────────────┐
   │ 08miniContext          │ 09themeSwitcher             │
   │────────────────────────│─────────────────────────────│
   │ createContext()        │ createContext({defaults})    │
   │ (no defaults)          │ (with default values!)      │
   │                        │                             │
   │ Separate Provider file │ ThemeContext.Provider        │
   │ with useState inside   │ exported directly           │
   │                        │ (state lives in App.jsx)    │
   │                        │                             │
   │ useContext() in each   │ Custom useTheme() hook      │
   │ component directly     │ (cleaner, less imports)     │
   └─────────────────────────────────────────────────────┘

   Why default values in createContext()?
   - If a component uses useTheme() but is NOT inside a Provider,
     it won't crash — it gets the default values instead.
   - Also helps with code autocompletion in editors!

========================================================
>> App.jsx — WHERE THE STATE LIVES
========================================================

   const [themeMode, setThemeMode] = useState("light");

   const lightTheme = () => setThemeMode("light");
   const darkTheme = () => setThemeMode("dark");

   // Actual DOM change — adds "dark" or "light" class to <html>
   useEffect(() => {
       document.querySelector("html").classList.remove("light", "dark");
       document.querySelector("html").classList.add(themeMode);
   }, [themeMode]);

   // Provide theme data to all children
   <ThemeProvider value={{ themeMode, lightTheme, darkTheme }}>
       <ThemeBtn/>
       <Card/>
   </ThemeProvider>

   IMPORTANT: The state (themeMode) and functions (lightTheme, darkTheme)
   are created HERE in App.jsx, not in the context file.
   The context file just provides the "pipeline" to share them.

========================================================
>> ThemeBtn.jsx — READS & CHANGES THEME
========================================================

   const { themeMode, darkTheme, lightTheme } = useTheme();
                                                 ↑ custom hook!
   (Instead of writing: useContext(ThemeContext) — cleaner!)

   On toggle switch change:
     if (checked) → darkTheme()   → sets themeMode to "dark"
     else         → lightTheme()  → sets themeMode to "light"

   The checkbox is controlled:
     checked={themeMode === "dark"}
     (stays in sync with context state)

   ── CONFUSING PART: TWO "checked" — WHAT'S THE DIFFERENCE? ──

   There are TWO "checked" in this component. They are NOT the same!

   1. checked={themeMode === "dark"}     (the PROP)
   2. e.currentTarget.checked            (the EVENT value)

   ┌──────────────────────────────┬──────────────────────────────┐
   │  checked={themeMode==="dark"}│  e.currentTarget.checked     │
   │──────────────────────────────│──────────────────────────────│
   │  A PROP on the checkbox      │  A VALUE from the event      │
   │  SETS what checkbox shows    │  READS what user just did    │
   │  React → Checkbox (output)   │  Checkbox → React (input)    │
   │  Runs on every render        │  Runs only on onChange       │
   │  Based on CONTEXT STATE      │  Based on USER'S CLICK       │
   └──────────────────────────────┴──────────────────────────────┘

   How they work together (step by step):

     User clicks toggle ON
       → onChange fires
       → e.currentTarget.checked = true    ← "user just checked it"
         → darkTheme() runs
           → themeMode becomes "dark"
             → Re-render happens
               → checked={"dark" === "dark"} = true
                                              ← "React confirms: stay ON"

   Think of it as:
     e.currentTarget.checked = "What did the user just do?" (INPUT)
     checked={...}           = "What should checkbox display?" (OUTPUT)

   They often have the SAME true/false value, but one READS
   the user action and the other CONTROLS what's shown on screen.

========================================================
>> Card.jsx — USES TAILWIND dark: CLASSES
========================================================

   Card doesn't use useTheme() at all!
   It uses Tailwind's dark: variant classes:

     className="bg-white dark:bg-gray-800"
     className="text-gray-900 dark:text-white"

   How does this work?
   - App.jsx adds "dark" class to <html> element via useEffect
   - Tailwind's dark: variant is configured in index.css:
       @custom-variant dark (&:where(.dark, .dark *));
   - When <html> has class "dark" → all dark: styles activate
   - When <html> has class "light" → normal styles apply

========================================================
>> FLOW OF THE APP
========================================================

   Step 1: App loads
     → themeMode = "light"
     → useEffect adds "light" class to <html>
     → Card shows light colors (white bg, dark text)
     → Toggle switch is unchecked

   Step 2: User clicks toggle switch ON
     → onChangeBtn fires → checked = true → darkTheme()
     → setThemeMode("dark")
     → useEffect runs → removes "light", adds "dark" to <html>
     → Tailwind dark: classes activate
     → Card turns dark (gray-800 bg, white text)

   Step 3: User clicks toggle switch OFF
     → onChangeBtn fires → checked = false → lightTheme()
     → setThemeMode("light")
     → useEffect runs → removes "dark", adds "light" to <html>
     → Card turns back to light colors

========================================================
>> DIAGRAM
========================================================

   ┌─────────────────────────────────────────────────┐
   │              ThemeProvider                       │
   │    value={{ themeMode, lightTheme, darkTheme }}  │
   │                                                  │
   │    ┌────────────────┐    ┌────────────────────┐  │
   │    │   ThemeBtn      │    │      Card           │  │
   │    │                 │    │                     │  │
   │    │ useTheme()      │    │ Uses Tailwind       │  │
   │    │ → reads themeMode│    │ dark: classes       │  │
   │    │ → calls darkTheme│    │ (auto-reacts to    │  │
   │    │   or lightTheme │    │  "dark" class on    │  │
   │    │                 │    │   <html>)           │  │
   │    └────────┬────────┘    └────────────────────┘  │
   │             │                                     │
   │             ↓                                     │
   │    App.jsx useEffect()                           │
   │    → adds "dark"/"light" class to <html>         │
   │    → Tailwind dark: styles activate/deactivate   │
   └─────────────────────────────────────────────────┘

========================================================
>> CUSTOM HOOK useTheme() — WHY?
========================================================

   Without custom hook (08miniContext way):
     import { useContext } from "react";
     import ThemeContext from "../contexts/theme";
     const { themeMode } = useContext(ThemeContext);
     // 2 imports + longer syntax

   With custom hook (09themeSwitcher way):
     import useTheme from "../contexts/theme";
     const { themeMode } = useTheme();
     // 1 import + shorter syntax

   Custom hook = wraps useContext() so consumers don't need
   to know about ThemeContext directly. Cleaner code!

========================================================
>> QUICK REVISION SUMMARY
========================================================

   • Context + Provider + custom hook — all in ONE file (theme.js)
   • createContext({defaults}) — provide default values for safety
   • ThemeProvider = ThemeContext.Provider (exported directly)
   • useTheme() = custom hook wrapping useContext(ThemeContext)
   • State lives in App.jsx, shared via ThemeProvider
   • useEffect in App.jsx adds "dark"/"light" class to <html>
   • Tailwind dark: variant handles the actual style changes
   • Card doesn't even import context — Tailwind does the work!

========================================================
