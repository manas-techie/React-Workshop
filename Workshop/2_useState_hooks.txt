
WHAT ARE HOOKS?
--------------------------------------------------------------------------------
- Hooks are special functions introduced in React 16.8
- Allow you to use state and other React features in FUNCTIONAL components
- Previously, these features were only available in CLASS components
- Hooks let you "hook into" React features without writing a class

WHY HOOKS?
--------------------------------------------------------------------------------
✅ Simpler code - no need for class components
✅ Reuse stateful logic between components
✅ Organize code by feature, not lifecycle methods
✅ Easier to test and understand
✅ No confusion with 'this' keyword


RULES OF HOOKS
--------------------------------------------------------------------------------
1. Only call hooks at the TOP LEVEL (not inside loops, conditions, or nested functions)
2. Only call hooks in REACT FUNCTIONS (functional components or custom hooks)
3. Hook names must start with "use" (e.g., useState, useEffect, useCustomHook)


COMMON BUILT-IN HOOKS
--------------------------------------------------------------------------------
1. useState      - Manage state in functional components
2. useEffect     - Perform side effects (API calls, subscriptions, DOM updates)
3. useContext    - Access context values
4. useRef        - Access DOM elements or persist values across renders
5. useReducer    - Manage complex state logic (alternative to useState)
6. useMemo       - Memoize expensive calculations
7. useCallback   - Memoize functions to prevent unnecessary re-renders


================================================================================
                    useState HOOK - DETAILED
================================================================================

WHAT IS useState?
--------------------------------------------------------------------------------
- Most commonly used hook
- Adds state management to functional components
- Returns an array with 2 elements:
  [1] Current state value
  [2] Function to update that state


SYNTAX
--------------------------------------------------------------------------------
const [state, setState] = useState(initialValue);

- state        : Current value of the state
- setState     : Function to update the state
- initialValue : Initial value (can be any type: number, string, object, array)


HOW IT WORKS
--------------------------------------------------------------------------------
1. React stores the state value between re-renders
2. When setState is called, React re-renders the component
3. On re-render, useState returns the UPDATED state value
4. State updates are ASYNCHRONOUS (not immediate)
5. Each component instance has its own isolated state


BASIC EXAMPLES
--------------------------------------------------------------------------------

Example 1: Counter
------------------
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);  // Initial value: 0

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}


Example 2: Input Field
----------------------
function Form() {
  const [name, setName] = useState('');  // Initial value: empty string

  return (
    <div>
      <input 
        type="text" 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
      />
      <p>Hello, {name}!</p>
    </div>
  );
}


Example 3: Boolean Toggle
--------------------------
function Toggle() {
  const [isOn, setIsOn] = useState(false);

  return (
    <button onClick={() => setIsOn(!isOn)}>
      {isOn ? 'ON' : 'OFF'}
    </button>
  );
}


Example 4: Object State
------------------------
function UserProfile() {
  const [user, setUser] = useState({ name: '', age: 0 });

  const updateName = (newName) => {
    setUser({ ...user, name: newName });  // Spread operator preserves other fields
  };

  return (
    <div>
      <input onChange={(e) => updateName(e.target.value)} />
      <p>Name: {user.name}, Age: {user.age}</p>
    </div>
  );
}


Example 5: Array State
-----------------------
function TodoList() {
  const [todos, setTodos] = useState([]);

  const addTodo = (todo) => {
    setTodos([...todos, todo]);  // Add new item to array
  };

  return (
    <div>
      <button onClick={() => addTodo('New Task')}>Add Todo</button>
      <ul>
        {todos.map((todo, index) => <li key={index}>{todo}</li>)}
      </ul>
    </div>
  );
}


IMPORTANT CONCEPTS
--------------------------------------------------------------------------------

1. FUNCTIONAL UPDATES
   When new state depends on previous state, use functional form:
   
   ❌ Wrong:  setCount(count + 1);  // May have stale value
   ✅ Correct: setCount(prevCount => prevCount + 1);


2. LAZY INITIALIZATION
   If initial state is expensive to compute, use function:
   
   const [state, setState] = useState(() => {
     return expensiveComputation();  // Only runs once on initial render
   });


3. STATE UPDATES ARE MERGED (NOT REPLACED)
   With objects, you must manually merge:
   
   setUser({ ...user, name: 'John' });  // Spread to keep other properties


4. MULTIPLE STATE VARIABLES
   You can use useState multiple times in one component:
   
   const [name, setName] = useState('');
   const [age, setAge] = useState(0);
   const [email, setEmail] = useState('');


5. BATCHING
   React batches multiple setState calls for performance:
   
   setCount(count + 1);
   setName('John');
   setAge(25);
   // Only ONE re-render happens, not three


COMMON MISTAKES
--------------------------------------------------------------------------------

❌ Directly mutating state:
   user.name = 'John';  // Wrong! React won't detect the change

✅ Create new object/array:
   setUser({ ...user, name: 'John' });


❌ Using state immediately after setting:
   setCount(5);
   console.log(count);  // Still shows OLD value (state updates are async)

✅ Use useEffect or functional update to access new value


❌ Calling useState conditionally:
   if (condition) {
     const [state, setState] = useState(0);  // Breaks rules of hooks!
   }

✅ Always call hooks at top level


WHEN TO USE useState
--------------------------------------------------------------------------------
✅ Form inputs (text, checkbox, radio)
✅ Toggles and boolean flags
✅ Counters and numeric values
✅ Lists and arrays that change
✅ Simple local component state

❌ For complex state logic → use useReducer
❌ For global state → use Context API or state management library (Redux, Zustand)


SUMMARY
--------------------------------------------------------------------------------
- useState adds state to functional components
- Returns [currentValue, updateFunction]
- State persists between re-renders
- Updating state triggers re-render
- Always use functional updates when new state depends on old state
- Don't mutate state directly - always create new values
- Can use multiple useState hooks in one component
